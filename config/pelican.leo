<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="yen.20170108171605.1"><vh>@settings</vh>
<v t="yen.20170108171605.2"><vh>@data qt-gui-plugin-style-sheet</vh></v>
<v t="yen.20170108171605.3"><vh>@string initial_split_orientation = horizontal</vh></v>
</v>
<v t="yen.20170108171733.1"><vh>@path ../</vh>
<v t="leo.20180115150519.1"><vh>@edit index.html</vh></v>
<v t="yen.20170108171733.3"><vh>@edit README.md</vh></v>
<v t="yen.20170108171733.4"><vh>@edit .gitignore</vh></v>
<v t="leo.20170908162839.1"><vh>沒有 disqus 論壇</vh>
<v t="yen.20170108171733.2"><vh>@button local-blog</vh></v>
</v>
<v t="leo.20170908162904.1"><vh>有 disqus 論壇</vh>
<v t="leo.20170709224430.1"><vh>@button github-blog</vh></v>
</v>
<v t="yen.20170108171733.5"><vh>Pelican 設定</vh>
<v t="leo.20170709020600.1"><vh>共用</vh></v>
<v t="yen.20170108171733.7"><vh>@edit pelicanconf.py</vh></v>
<v t="leo.20170709015947.1"><vh>遠端</vh></v>
<v t="leo.20170709015955.1"><vh>@edit publishconf.py</vh></v>
<v t="leo.20170709015940.1"><vh>近端</vh></v>
<v t="yen.20170108171733.6"><vh>@edit local_publishconf.py</vh></v>
</v>
<v t="yen.20170224232341.1"><vh>編輯 template</vh>
<v t="leo.20180115093448.1"><vh>@path theme/attila/templates</vh>
<v t="leo.20180715212936.1"><vh>@edit article.html</vh></v>
<v t="leo.20180115093536.1"><vh>@edit base.html</vh></v>
<v t="leo.20180115093657.1"><vh>@edit search.html</vh></v>
<v t="leo.20180115093715.1"><vh>@edit archives.html</vh></v>
<v t="leo.20180715212745.1"><vh>@edit categories.html</vh></v>
<v t="leo.20180715212902.1"><vh>@edit index.html</vh></v>
<v t="leo.20180115093726.1"><vh>@path partials</vh>
<v t="leo.20180115093749.1"><vh>@edit navigation.html</vh></v>
</v>
<v t="leo.20180115142025.1"><vh>保留之前舊的設定檔案</vh></v>
</v>
<v t="yen.20170224232341.2"><vh>@path theme/pelican-bootstrap3_local/templates</vh></v>
<v t="leo.20170710015301.1"><vh>@path theme/pelican-bootstrap3/templates</vh></v>
</v>
<v t="leo.20170710015511.1"><vh>編輯 plugin</vh>
<v t="leo.20170710015523.1"><vh>@path plugin</vh>
<v t="leo.20170710015523.2"><vh>@path tipue_search</vh>
<v t="leo.20170710015523.3"><vh>@edit tipue_search.py</vh></v>
</v>
</v>
</v>
<v t="yen.20170108171733.71"><vh>@path markdown</vh>
<v t="yen.20170108171733.81"><vh>@path pages</vh>
<v t="yen.20170108171733.82"><vh>@edit pages_1.md</vh></v>
</v>
</v>
<v t="leo.20170710022054.1"><vh>可以另建節點存放 markdown 目錄下的 md 檔案</vh></v>
<v t="leo.20170710022041.1"><vh>@path markdown</vh>
<v t="leo.20180115115910.1"><vh>2018</vh>
<v t="leo.20180423103639.1"><vh>2018 Fall CP 課程</vh>
<v t="leo.20180909205246.1"><vh>@clean 20200522w10.md</vh>
<v t="leo.20200529161544.1"><vh>2020w10</vh></v>
<v t="leo.20200605080331.1"><vh>6567815351821584885</vh></v>
</v>
<v t="leo.20200522142001.1"><vh>@clean 20200522w11.md</vh>
<v t="leo.20200529161820.1"><vh>2020w11</vh></v>
<v t="leo.20200605080407.1"><vh>2427680632846859988</vh></v>
</v>
<v t="leo.20200522142040.1"><vh>@clean 20200522w12.md</vh>
<v t="leo.20200529161821.1"><vh>2020w12</vh></v>
<v t="leo.20200605160253.1"><vh>6009178716273774234</vh></v>
</v>
<v t="leo.20200529143629.1"><vh>@clean 20200529w13.md</vh>
<v t="leo.20200529161822.1"><vh>2020w13</vh></v>
<v t="leo.20200605080307.1"><vh>4508951632052810118</vh></v>
</v>
<v t="leo.20200605162113.1"><vh>@clean 20200605w14.md</vh>
<v t="leo.20200605162217.1"><vh>2020w14</vh></v>
<v t="leo.20200605163334.1"><vh>46306560224620819</vh></v>
</v>
<v t="leo.20200613133438.1"><vh>@clean 20200613w1.md</vh>
<v t="leo.20200613133446.1"><vh>2020w1</vh></v>
<v t="leo.20200613140236.1"><vh>4539309400801009659</vh></v>
</v>
<v t="leo.20200613060415.1"><vh>@clean 20200613w2.md</vh>
<v t="leo.20200613060452.1"><vh>2020w2</vh></v>
<v t="leo.20200613060649.1"><vh>4079915860262074163</vh></v>
</v>
<v t="leo.20200613060704.1"><vh>@clean 20200613w3.md</vh>
<v t="leo.20200613060735.1"><vh>2020w3</vh></v>
<v t="leo.20200613060942.1"><vh>6052849679371791581</vh></v>
</v>
<v t="leo.20200613060956.1"><vh>@clean 20200613w4.md</vh>
<v t="leo.20200613061034.1"><vh>2020w4</vh></v>
<v t="leo.20200613062511.1"><vh>6595911639768605329</vh></v>
</v>
<v t="leo.20200613061922.1"><vh>@clean 20200613w5.md</vh>
<v t="leo.20200613062029.1"><vh>2020w5</vh></v>
<v t="leo.20200613142500.1"><vh>820243495845947964</vh></v>
</v>
<v t="leo.20200613062638.1"><vh>@clean 20200613w6.md</vh>
<v t="leo.20200613143206.1"><vh>2020w6</vh></v>
<v t="leo.20200613143242.1"><vh>4572045871020345894</vh></v>
</v>
<v t="leo.20200613143457.1"><vh>@clean 20200613w7-8.md</vh>
<v t="leo.20200613143723.1"><vh>2020w7-8</vh></v>
<v t="leo.20200613143833.1"><vh>3388616831126172874</vh></v>
</v>
<v t="leo.20200613150157.1"><vh>@clean 20200613w9.md</vh>
<v t="leo.20200613150338.1"><vh>2020w9</vh></v>
<v t="leo.20200613151241.1"><vh>2956968901738808800</vh></v>
</v>
<v t="leo.20200613151258.1"><vh>@clean 20200613w14.md</vh>
<v t="leo.20200613151738.1"><vh>2020w15-18</vh></v>
<v t="leo.20200613151827.1"><vh>5476510886177340582</vh></v>
</v>
</v>
</v>
</v>
<v t="yen.20170108171733.83"><vh>產生 .key 與 .crt 指令</vh></v>
</v>
<v t="yen.20170108171930.1"><vh>@button https server</vh></v>
<v t="yen.20170108171939.1"><vh>@button ipv6 https server</vh></v>
<v t="leo.20200529145620.1"><vh>@button add_to_blogger</vh></v>
<v t="leo.20200529145620.2"><vh>@button edit_to_blogger</vh></v>
</vnodes>
<tnodes>
<t tx="leo.20170709015940.1"></t>
<t tx="leo.20170709015947.1"></t>
<t tx="leo.20170709020600.1"></t>
<t tx="leo.20170709224430.1">@language python
import os

os.system("pelican markdown -o blog -s publishconf.py")
g.es("admin pelican Github 執行完畢")


</t>
<t tx="leo.20170710015301.1"></t>
<t tx="leo.20170710015511.1"></t>
<t tx="leo.20170710015523.1"></t>
<t tx="leo.20170710015523.2"></t>
<t tx="leo.20170710022041.1"></t>
<t tx="leo.20170710022054.1"></t>
<t tx="leo.20170908162839.1"></t>
<t tx="leo.20170908162904.1"></t>
<t tx="leo.20180115093448.1"></t>
<t tx="leo.20180115093726.1"></t>
<t tx="leo.20180115115910.1"></t>
<t tx="leo.20180115142025.1"></t>
<t tx="leo.20180423103639.1"></t>
<t tx="leo.20180909205246.1">@language md
---
Title: 2020wcmj W10
Date: 2020-05-22 14:00
Category: Misc
Tags: 2020WCMJ
Slug: 2020-wcm-w10-summary
Author: 50833106
---

以 SSH 維護倉儲

&lt;!-- PELICAN_END_SUMMARY --&gt;

@others</t>
<t tx="leo.20200522142001.1">@language md
---
Title: 2020wcmj W11
Date: 2020-05-22 14:00
Category: Misc
Tags: 2020WCMJ
Slug: 2020-wcm-w11-summary
Author: 50833106
---
ssh 之用法
&lt;!-- PELICAN_END_SUMMARY --&gt;

@others</t>
<t tx="leo.20200522142040.1">@language md
---
Title: 2020wcmj W12
Date: 2020-05-22 14:00
Category: Misc
Tags: 2020WCMJ
Slug: 2020-wcm-w12-summary
Author: 50833106
---
Leo Editor 基本用法

&lt;!-- PELICAN_END_SUMMARY --&gt;

@others</t>
<t tx="leo.20200529143629.1">@language md
---
Title: 2020wcmj W13
Date: 2020-05-29 14:00
Category: Misc
Tags: 2020WCMJ
Slug: 2020-wcm-w13-summary
Author: 50833106
---
Pelican Blog 內容與 Google Blogger 同步


&lt;!-- PELICAN_END_SUMMARY --&gt;

@others</t>
<t tx="leo.20200529145620.1">@language python
from markdown import markdown
from oauth2client import client
from googleapiclient import sample_tools
import os

os.environ['TZ'] = 'Asia/Taipei'
argv = ""
# 認證並建立服務
# name of the api is "blogger", version is "v3"
# description of the api is __doc__
# file name of the application: location of client_secrets.json
service, flags = sample_tools.init(
  argv, 'blogger', 'v3', __doc__, "./../../client_secrets.json",
  scope='https://www.googleapis.com/auth/blogger')


def get_cat_tag_content(data):
    # 請注意, 因為 data 來自 .md 的檔案 內容, 第1行為 ---
    # 用跳行符號分割
    data_list = data.split("\n")
    #第 2 行為 title
    title= data_list[1]
    #第 4 行為 category
    category = data_list[3]
    #第 5 行為 tags
    tags = data_list[4]
    # 有多項資料的 content 型別為數列
    # 再將第 9 行之後的資料數列串回成以跳行隔開的資料
    content = "\n".join(data_list[8:])
    # 先將截斷摘要與內文的 pelican md 檔按符號, 換成 Blogger 的 &lt;!--more--&gt;
    content = content.replace('&lt;!-- PELICAN_END_SUMMARY --&gt;', '&lt;!--more--&gt;')
    # 接著若內容有 ~~~python 與 ~~~ 則換成 Wordpress 格式
    #content = content.replace('~~~python', '[code lang="python"]')
    #content = content.replace('~~~', '[/code]')
    return title, category, tags, content

# 從目前所在節點的 body pan 中取出類別, tags 以及文章內容
# p.h 為 @clean filename.md
# 因為要使用 @clean 節點掛上為後的 blogger post_id, 因此改為讀 .md 檔案
md_filename = p.h.split(" ")[1]
with open(md_filename, 'r', encoding="utf-8") as content_file:
    md_content = content_file.read()
# title_str, category_str, tags_str, content = get_cat_tag_content(p.b)
title_str, category_str, tags_str, content = get_cat_tag_content(md_content)
category = category_str.split(":")[1]
tags = tags_str.split(":")[1].split(",")
tags.append(category)
# title 是一個單獨的字串
title = title_str.split(":")[1]
# 將 markdown 格式 content 轉為 html
content = markdown(content)
# 以下處理 content 的 &lt;h2&gt; 標題
content = content.replace("&lt;h2&gt;", "&lt;h2&gt;&lt;font size='4'&gt;")
content = content.replace("&lt;/h2&gt;", "&lt;/font&gt;&lt;/h2&gt;")
# g.es(content)

try:
    '''
    users = service.users()
    # 取得使用者 profile 資料
    user = users.get(userId='self').execute()
    print('網誌名稱: %s' % user['displayName'])
    '''
    blogs = service.blogs()
    # 取得使用者所建立網誌名稱
    blogs = blogs.listByUser(userId='self').execute()
    # post_id is now blogs["items"][0]["id"]
    blog_id = blogs["items"][0]["id"]
    #for blog in blogs['items']:
        #print(blog['name'], blog['url'])
    posts = service.posts()
    # 新增網誌 post 時, 需要 post_id
    body = {
    "kind": "blogger#post",
    "id": blog_id,
    "title": title,
    # 利用 markdown 函式, 將 .md 的內文轉為 html, 作為 Blogger 的文章內容
    "content": content,
    "labels": tags
    }
    insert = posts.insert(blogId=blog_id, body=body)
    posts_doc = insert.execute()
    post_id = posts_doc["id"]
    #print(posts_doc)
    os.remove("blogger.dat")
    # 利用最後的 child 節點來儲存 post_id
    to_save_post_id = p.insertAsLastChild()   
    # 改為內文為空的節點, id 直接標在 head 標題 
    to_save_post_id.b = ""
    to_save_post_id.h = post_id
    # 因為新增節點, commander 必須 redraw
    c.redraw()
    g.es("post_id 為", post_id)
    g.es("已經將資料送往 Blogger!")
except(client.AccessTokenRefreshError):
    g.es("error")</t>
<t tx="leo.20200529145620.2">@language python
from markdown import markdown
from oauth2client import client
from googleapiclient import sample_tools
import os

os.environ['TZ'] = 'Asia/Taipei'
argv = ""
# 認證並建立服務
# name of the api is "blogger", version is "v3"
# description of the api is __doc__
# file name of the application: location of client_secrets.json
service, flags = sample_tools.init(
  argv, 'blogger', 'v3', __doc__, "./../../client_secrets.json",
  scope='https://www.googleapis.com/auth/blogger')


def get_cat_tag_content(data):
    # 請注意, 因為 data 來自 .md 的檔案 內容, 第1行為 ---
    # 用跳行符號分割
    data_list = data.split("\n")
    #第 2 行為 title
    title= data_list[1]
    #第 4 行為 category
    category = data_list[3]
    #第 5 行為 tags
    tags = data_list[4]
    # 有多項資料的 content 型別為數列
    # 再將第 9 行之後的資料數列串回成以跳行隔開的資料
    content = "\n".join(data_list[8:])
    # 先將截斷摘要與內文的 pelican md 檔按符號, 換成 Blogger 的 &lt;!--more--&gt;
    content = content.replace('&lt;!-- PELICAN_END_SUMMARY --&gt;', '&lt;!--more--&gt;')
    # 接著若內容有 ~~~python 與 ~~~ 則換成 Wordpress 格式
    #content = content.replace('~~~python', '[code lang="python"]')
    #content = content.replace('~~~', '[/code]')
    return title, category, tags, content

# 從目前所在節點的 body pan 中取出類別, tags 以及文章內容
# p.h 為 @clean filename.md
# 因為要使用 @clean 節點掛上為後的 blogger post_id, 因此改為讀 .md 檔案
md_filename = p.h.split(" ")[1]
with open(md_filename, 'r', encoding="utf-8") as content_file:
    md_content = content_file.read()
# title_str, category_str, tags_str, content = get_cat_tag_content(p.b)
title_str, category_str, tags_str, content = get_cat_tag_content(md_content)
category = category_str.split(":")[1]
tags = tags_str.split(":")[1].split(",")
tags.append(category)
# title 是一個單獨的字串
title = title_str.split(":")[1]
# 將 markdown 格式 content 轉為 html
content = markdown(content)
# 以下處理 content 的 &lt;h2&gt; 標題
content = content.replace("&lt;h2&gt;", "&lt;h2&gt;&lt;font size='4'&gt;")
content = content.replace("&lt;/h2&gt;", "&lt;/font&gt;&lt;/h2&gt;")
# g.es(content)

try:
    blogs = service.blogs()
    # 取得使用者所建立網誌名稱
    blogs = blogs.listByUser(userId='self').execute()
    blog_id = blogs["items"][0]["id"]
    # 設法取得原 post 的 id
    postid_outline = p.getLastChild()
    # 直接從標題取得 post 的 id 號碼
    post_id = postid_outline.h
    posts = service.posts()
    # 更新網誌文章時的 body
    body = {
    "kind": "blogger#post",
    "title": title,
    "content": content
    }
    # need to save postId to outline head
    update = posts.update(blogId=blog_id, postId=post_id, body=body, publish=True)
    update_doc = update.execute()
    os.remove("blogger.dat")
    g.es("post_id 為", post_id)
    g.es("已經將更新資料送往 Blogger!")
except(client.AccessTokenRefreshError):
    g.es("error")</t>
<t tx="leo.20200529161544.1">由於在電腦教室時採用純 IPv6 協定上網, 因此為了能夠在近端將倉儲改版資料推送到目前只接受 IPv4 協定連線的 github, 以下除了將原本以 https 對 github 連線, 改為以 ssh 協定連線外, 在 Windows 環境下必須利用 putty 與 plink, 設定 putty 格式的 .ppk 以及能夠同時支援 IPv4 與 IPv6 的代理主機.</t>
<t tx="leo.20200529161820.1">1.下載 Putty 工具組
2.利用 y:\portablegit\bin\sh.exe 進入 shell 命令環境後, 以 ssh-keygen -t rsa -b 4096 -C "使用者學號"在 /y/home/.ssh 目錄下建立 id_rsa 與 id_rsa.pub 等 private key 與 public key,之後以 SciTE 開啟 id_rsa.pub 後, 將此 public key 的內容, 以新增添加到 Github.com 帳號下 personal settings -&gt; SSH and GPG keys 頁面下.
3.接下來要利用 puttygen.exe 將 id_rsa 轉為 Putty 可以解讀的 .ppk 格式, 並修改隨身系統的啟動批次檔案, 指定利用 putty 目錄下的 plink 執行 git 指令的網路代理設定.修改啟動的 start.bat 加入下列設定:
 set GIT_HOME=%Disk%:\portablegit\bin\
set GIT_SSH=%Disk%:\putty\plink.exe
4.利用 puttygen.exe 載入第二步驟所建立的 private key, 也就是 id_rsa.
開啟 puttygen 之後, 以右下方的 load 載入 id_rsa, 成功載入後, 利用 save private key 按鈕, 將已經轉為 putty 格式的 .ppk 存檔. 此一 .ppk 檔案必須在設定 putty 中 github.com session 時, 在 Connection-&gt;SSH-&gt;Auth 項目下, 將轉檔後的 .ppk 指向 private key file for authentication 欄位. 並在 Connection-&gt;Proxy 項目下, 指定 Proxy type: HTTP, 並將 IPv6 代理主機設為 ::53 或 ::42 埠號設為 3128.

5.之後確定 home 下的 .ssh 目錄中的 config 
6.最後再將 wcmj2020 倉儲中 .git 目錄下的 config 檔案中的連線協定, 由 https 改為採 ssh 連線
之後就可以透過近端的 .ppk private key 與 Github.com 上的 public key 對應, 無需輸入帳號密碼就可以進行 git push.

</t>
<t tx="leo.20200529161821.1">Leo Editor 基本用法
首先必須要在隨身程式系統的命令列視窗中, 以 leo 啟動 Leo Editor, 然後開啟 [wcmj2020] 倉儲 config 目錄中的 pelican.leo 檔案.

由於 Leo Editor 是一個大綱管理系統, 淡黃色區域是大綱節點區, 淡紅色區是與各大綱對應的內文區, 而淡藍色則是 Log 輸出區.

在 Leo Editor 中新增節點的指令: ctrl + i, 表示要 insert 一個新的節點.

在 Leo Editor 中向右移動節點的方法: ctrl + r, 表示要將節點往 right (右) 移動.

在 Leo Editor 中向左移動節點的方法: ctrl + l, 表示要將節點往 left (左) 移動.

在 Leo Editor 中向上移動節點的方法: ctrl + u, 表示要將節點往 up (上) 移動.

在 Leo Editor 中向下移動節點的方法: ctrl + d, 表示要將節點往 down (下) 移動.
</t>
<t tx="leo.20200529161822.1">利用 Windows 10 設定 -&gt; 選擇預設網頁瀏覽器, 使用 Google Chrome 作為預設瀏覽器.

隨身程式系統必須安裝 google-api-python-client 與 oauth2client

pip install google-api-python-client oauth2client

OAuth 2.0 client IDs 程式類別可以選擇 other

使用者完成 client_secrets.json 設定後, 必須將檔案存在倉儲目錄外部
</t>
<t tx="leo.20200605080307.1"></t>
<t tx="leo.20200605080331.1"></t>
<t tx="leo.20200605080407.1"></t>
<t tx="leo.20200605160253.1"></t>
<t tx="leo.20200605162113.1">@language md
---
Title: 2020wcmj W14
Date: 2020-06-05 16:00
Category: Misc
Tags: 2020WCMJ
Slug: 2020-wcm-w14-summary
Author: 50833106
---
使Pelican Blog 內容與 Google Blogger 同步


&lt;!-- PELICAN_END_SUMMARY --&gt;

@others</t>
<t tx="leo.20200605162217.1">透過 Python 程式修改網誌文章,使用 Google Blogger API 可以利用程式修改網誌文章內容,執行以下程式, 需要擷取 client_secrets.json 權限資料</t>
<t tx="leo.20200605163334.1"></t>
<t tx="leo.20200613060415.1">@language md
---
Title: 2020wcmj W2
Date: 2020-06-13 14:00
Category: Misc
Tags: 2020WCMJ
Slug: 2020-wcm-w2-summary
Author: 50833106
---
w2



&lt;!-- PELICAN_END_SUMMARY --&gt;

@others</t>
<t tx="leo.20200613060452.1">課程小筆記

IPv4 version 4 IP 四個區段,用.隔開
IPv6 version 6 IP 八個區段,用:隔開
[2001:288:6004:17::53]:3128 140.130.17.53:3128
[2001:288:6004:17::42]:3128 140.130.17.53:254(系gateway通道)
[2001:288:6004:17::17]:3128 140.130.1.*(校主幹)
[2001:288:6004:17::7]:3128
課程小單字
tcp/ip==trandmision control protocol/internet protocol
inter-net==inter-national(國際)
(網際,inter+networt)
protocal 協定
microscope 顯微鏡
telescope 望遠鏡
trasmit 傳輸
data 資料
packet 封包
control 控制
macro 巨(比原子(atom)大)
atomic bomb 原子彈中華電信 dns. server. dns==domain name server 符號名稱伺服器
version 版本(短時間)
edition 版本(長時間)
router 路由器
route 路徑
remote login 遠端登入
micro 微</t>
<t tx="leo.20200613060649.1"></t>
<t tx="leo.20200613060704.1">@language md
---
Title: 2020wcmj W3
Date: 2020-06-13 14:00
Category: Misc
Tags: 2020WCMJ
Slug: 2020-wcm-w3-summary
Author: 50833106
---
建立可攜式環境



&lt;!-- PELICAN_END_SUMMARY --&gt;

@others</t>
<t tx="leo.20200613060735.1">為了讓工程師可以在不同的 Windows 10 64 位元電腦上管理 CMSiMDE 網際內容管理系統, 因此需要 Python 解譯環境以及一個文字檔案的編輯器.

這裡所安裝的 Python 解譯器選擇由 C 所編寫的 CPython, 可以從 https://www.python.org/  下載安裝. 但是在此我們要將 Python 解譯系統配置在 USB 隨身碟上, 使用者可以隨身攜帶, 一旦配置完成後, 可以在任何一台 Windows 10 64 位元的筆電或電腦上執行 Python 或 C 程式.

可攜 Python 程式環境的建立步驟:

安裝 Python 套件時, 不要安裝 pip, 之後將 Python38 目錄複製到 data 目錄中, 然後建立 start.bat 指定使用可攜系統中的 Python, 之後再利用 get-pip.py, 以命令列中的 python get-pip.py 安裝 pip.

可攜 Tiny C 程式環境的建立步驟:

從 https://bellard.org/tcc/ 下載 Tiny C, 將 tcc 解開壓縮後放到 data 目錄中. 然後修改 wscite 目錄中的 cpp.properties, 使用 Tiny C 類解譯 .c 程式.

選用的文字編輯器: https://www.scintilla.org/SciTE.html

建立完成的可攜程式環境:

下載 wcmj2020_tool.7z, 檔案大小為 435 MB, 解開壓縮後為 1.8 GB (其中包括 Mypaint, Dia 與 OBS 等)

將 wcmj2020_tool.7z 解壓縮到隨身碟或電腦硬碟中, 將 home 與 home_ipv6 目錄中的 .gitconfig user.name 與 user.email 改為自己的 Github 帳號與 email 後, 利用 start.bat 啟動可攜系統, 利用 stop.bat 關閉可攜系統.

</t>
<t tx="leo.20200613060942.1"></t>
<t tx="leo.20200613060956.1">@language md
---
Title: 2020wcmj W4
Date: 2020-06-13 14:00
Category: Misc
Tags: 2020WCMJ
Slug: 2020-wcm-w4-summary
Author: 50833106
---
建網站


&lt;!-- PELICAN_END_SUMMARY --&gt;

@others</t>
<t tx="leo.20200613061034.1">此內容管理系統以 https:..github.com.mdecourse.cmsimde 作為 submodule 運作, 可以選定對應的版本運作, cmsimde 可以持續改版, 不會影響之前設為 submodule, 使用舊版 cmsimde 模組的內容管理相關運作.
利用 cmsimde 建立靜態網誌方法:
在 github 建立倉儲, git clone 到近端
參考https:..github.com.mdecourse.newcms, 加入除了 cmsimde 目錄外的所有內容
以 git submodule add https:..github.com.mdecourse.cmsimde cmsimde
建立 cmsimde 目錄, 並從 github 取下子模組內容.
3.在近端維護時, 更換目錄到倉儲中的 cmsimde, 以 python wsgi.py 啟動近端網際伺服器.
動態內容編輯完成後, 以 generate_pages 轉為靜態內容, 以 git add commit 及 push 將內容推到遠端.
之後若要以 git clone 取下包含 submodule 的所有內容, 執行:
git clone --recurse-submodules https:..github.com.mdecourse.newcms.git
</t>
<t tx="leo.20200613061922.1">@language md
---
Title: 2020wcmj W5
Date: 2020-06-13 14:00
Category: Misc
Tags: 2020WCMJ
Slug: 2020-wcm-w5-summary
Author: 50833106
---
w5


&lt;!-- PELICAN_END_SUMMARY --&gt;

@others</t>
<t tx="leo.20200613062029.1">筆記
firmwarre 韌體
software 軟體
hardware 硬體
terminology 專業術語
particular 特別
technical 技術
application 應用
command wundow 命令視窗
submodule 子模組
machine language 機器語言
URL:Uniform Resourse Locator 統一資源定位


程式令:
Y:←指y槽
Y:\ ←表示Y槽的root根目錄
&gt; 為回應符號(prormptsign)
\ 為blackslash 反斜線
dir為顯示目錄內容的指令
cd tmp 表示change directory 到指定的目錄
git為分散式版次管理的指令名稱
git clone表示要使用git對遠端的倉儲進行clone。
課堂小單字
shell 殼
interface 介面
device 物件
graphics 圖形
</t>
<t tx="leo.20200613062511.1"></t>
<t tx="leo.20200613062638.1">@language md
---
Title: 2020wcmj W6
Date: 2020-06-13 14:30
Category: Misc
Tags: 2020WCMJ
Slug: 2020-wcm-w6-summary
Author: 50833106
---
 portable obs教學


&lt;!-- PELICAN_END_SUMMARY --&gt;

@others</t>
<t tx="leo.20200613133438.1">@language md
---
Title: 2020wcmj W1
Date: 2020-06-13 14:00
Category: Misc
Tags: 2020WCMJ
Slug: 2020-wcm-w1-summary
Author: 50833106
---
建立blogger



&lt;!-- PELICAN_END_SUMMARY --&gt;

@others</t>
<t tx="leo.20200613133446.1">建立blogger

課程小單字

1 super computer 超級電腦
2pc=person computer 個人電腦 
3mainframe 伺服器主機
4 server 伺服器 (虛擬 實體)
5 mobile phone 手機
6 microcontroller 微控制器
Port 埠號
DHCP動態網路位置</t>
<t tx="leo.20200613140236.1"></t>
<t tx="leo.20200613142500.1"></t>
<t tx="leo.20200613143206.1">portable obs
google hangout meet
streeming and recording
---------------------------------------------------------------------------------------------------------------
讓手機可以利用電腦熱點上網：
採用 https://www.tp-link.com/us/home-networking/usb-adapter/tl-wn725n/
將此一 USB Wifi adapter 連接電腦後, 若網路為 IPv4 協定時, 可以透過"設定 -&gt; 網路和網際網路 -&gt; 行動熱點", 選擇開啟並編輯"網路名稱與網路密碼"後, 讓至多 8 台手機透過熱點連線上網。
但是因為目前 Windows 10 並未提供 IPv6 網路協定下的網路熱點功能, 因此在純 IPv6 網路協定下無法使用"行動熱點"服務。
利用手機鏡頭當作 webcam:
Android: https://www.digitalcitizen.life/turn-android-smartphone-webcam-windows
iPhone: https://www.makeuseof.com/tag/use-your-iphone-as-a-webcam-heres-how-ios/
需要 clone 個人倉儲時：
git clone --recurse-submodules 倉儲_url.git
例如: git clone --recurse-submodules https://github.com/mdecourse/wcmj2020.git
現場直播的 audio 錄音設定
在電腦輔助設計室進行直播時, 由於現場有擴音設備, 因此採用 OBS 串流至 Youtube 的最佳收音並非從 Webcam 的麥克風, 而是從擴音器以 audio outpu 連接到電腦的麥克風插槽, 然後將 OBS 的 audio 設定為從電腦的麥克風收音.
</t>
<t tx="leo.20200613143242.1"></t>
<t tx="leo.20200613143457.1">@language md
---
Title: 2020wcmj W7-8
Date: 2020-06-13 14:30
Category: Misc
Tags: 2020WCMJ
Slug: 2020-wcm-w7.8-summary
Author: 50833106
---
 grouping and meeting

&lt;!-- PELICAN_END_SUMMARY --&gt;

@others</t>
<t tx="leo.20200613143723.1">第三組group3
50833104 組長
50833106
50833113
50833114
50833116
50833118
50833120
50833125
50833140
50833141
proxy
2001:288:6004:17::53
2001:288:6004:17::42
2001:288:6004:17::17
2001:288:6004:17::4 "虛擬主機 可以校外連接"
下周可能線上上課</t>
<t tx="leo.20200613143833.1"></t>
<t tx="leo.20200613150157.1">@language md
---
Title: 2020wcmj W9
Date: 2020-06-13 15:00
Category: Misc
Tags: 2020WCMJ
Slug: 2020-wcm-w9-summary
Author: 50833106
---
期中考

&lt;!-- PELICAN_END_SUMMARY --&gt;

@others</t>
<t tx="leo.20200613150338.1">學習這幾周下來之心得

w1教我們如何建立blogger

w2-4則是教我們如何用git指令建立cmsimde網站，並如何維護

而w6-w9則是教學如何開直播</t>
<t tx="leo.20200613151241.1"></t>
<t tx="leo.20200613151258.1">@language md
---
Title: 2020wcmj W15-18
Date: 2020-06-13 15:00
Category: Misc
Tags: 2020WCMJ
Slug: 2020-wcm-w15.18-summary
Author: 50833106
---
統整

&lt;!-- PELICAN_END_SUMMARY --&gt;

@others</t>
<t tx="leo.20200613151738.1">將 W1-W14 週的所有上課內容, 以圖文及影音資料加以整理在個人及分組倉儲、網站及簡報外,還要自選另一主題, 將分組協同的過程與內容整理在個人與分組的倉儲資料中.</t>
<t tx="leo.20200613151827.1"></t>
<t tx="yen.20170108171605.1"></t>
<t tx="yen.20170108171605.2">QTreeWidget {
    /* These apply to the selected item, but not to editing items.*/
    background-color: #ffffec; /* Leo's traditional tree color */
    selection-color: black; /* was white */
    selection-background-color: lightgrey;
    /* font-family: SansSerif; */
    /*font-family: DejaVu Sans Mono;*/
    font-family:YaHei Mono;
    /* 標題字型大小設定 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
 }

/* Headline edit widgets */
QTreeWidget QLineEdit {
    background-color: cornsilk;
    selection-color: white;
    selection-background-color: blue;
    /*font-family: DejaVu Sans Mono;*/    
    font-family:YaHei Mono;
    /* 沒有特別對應字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The log panes */
QTextEdit {
    background-color: #f2fdff;
    selection-color: red;
    selection-background-color: blue;
    /* font-family: Courier New; */
    font-family:YaHei Mono;
    /* log font 大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The body pane */
QTextEdit#richTextEdit {
    background-color: #fdf5f5; /* A kind of pink. */
    selection-color: white;
    selection-background-color: red;
    /*font-family: DejaVu Sans Mono;*/
    /* font-family: Courier New; */
    font-family:YaHei Mono;
    /* 內文字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

QLabel {
    font-family:YaHei Mono;'CherryPy', 'pytz', 'mako', 'beautifulsoup4', 'pymysql', 'peewee'
    /* 下方的 Minibuffer 標題字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

/* Editor labels */
QLineEdit#editorLabel {
    background-color: #ffffec;
    font-family:YaHei Mono;
    /* 沒有直接對應字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
    border: 2px;
    margin: 2px;
}</t>
<t tx="yen.20170108171605.3">horizontal: body pane to the left
vertical: body pane on the botton</t>
<t tx="yen.20170108171733.1"></t>
<t tx="yen.20170108171733.2">@language python
import os

os.system("pelican markdown -o blog -s local_publishconf.py")
g.es("admin pelican 近端執行完畢")


</t>
<t tx="yen.20170108171733.5"></t>
<t tx="yen.20170108171733.71"></t>
<t tx="yen.20170108171733.81"></t>
<t tx="yen.20170108171733.83">sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout localhost.key -out localhost.crt

</t>
<t tx="yen.20170108171930.1">@language python
import os
import subprocess
import threading
import http.server, ssl

def domake():
    # build directory
    os.chdir("./../")
    server_address = ('localhost', 5443)
    httpd = http.server.HTTPServer(server_address, http.server.SimpleHTTPRequestHandler)
    httpd.socket = ssl.wrap_socket(httpd.socket,
                                   server_side=True,
                                   certfile='localhost.crt',
                                   keyfile='localhost.key',
                                   ssl_version=ssl.PROTOCOL_TLSv1)
    print(os.getcwd())
    print("5443 https server started")
    httpd.serve_forever()

# 利用執行緒執行 https 伺服器
make = threading.Thread(target=domake)
make.start()</t>
<t tx="yen.20170108171939.1">@language python
import os
import subprocess
import threading
import socket
import http.server, ssl

class HTTPServerV6(http.server.HTTPServer):
    address_family = socket.AF_INET6
  
def domake():
    # build directory
    os.chdir("./../")
    ipv6_address = '::1'
    server_address = (ipv6_address, 6443)
    #httpd = http.server.HTTPServer(server_address, http.server.SimpleHTTPRequestHandler)
    httpd = HTTPServerV6(server_address, http.server.SimpleHTTPRequestHandler)
    httpd.socket = ssl.wrap_socket(httpd.socket,
                                   server_side=True,
                                   certfile='localhost.crt',
                                   keyfile='localhost.key',
                                   ssl_version=ssl.PROTOCOL_TLSv1)
    print("6443 https server started")
    httpd.serve_forever()

# 利用執行緒執行 https 伺服器
make = threading.Thread(target=domake)
make.start()</t>
<t tx="yen.20170224232341.1"></t>
<t tx="yen.20170224232341.2"></t>
</tnodes>
</leo_file>
